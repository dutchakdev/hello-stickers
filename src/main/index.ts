import { app, BrowserWindow, ipcMain, dialog, protocol, Menu, WebContents } from 'electron';
import * as path from 'path';
import * as fs from 'fs';
import { exec, execFile } from 'child_process';
import { platform } from 'os';
import db from '../database/db';
import * as https from 'https';
import * as http from 'http';
import { URL } from 'url';
import * as googleDrive from '../lib/google-drive';
import { syncWithNotion } from '../lib/notion';
import * as querystring from 'querystring';

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// This allows TypeScript to pick up the magic constants that's auto-generated by Electron Forge.
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
      webSecurity: true,
      sandbox: false
    },
  });

  // Content security policy to protect against XSS
  const csp = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-eval'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: app: https://* file:",
    "media-src 'self' app:",
    "font-src 'self'",
    "object-src 'self' app: blob:",
    "connect-src 'self' https://*"
  ].join('; ');
  
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [csp]
      }
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
  
  console.log('Preload path:', MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY);
};

// This method will be called when Electron has finished initialization
// and is ready to create browser windows.
app.whenReady().then(() => {
  // Initialize database
  db.initDatabase();
  
  // Ensure directories exist
  ensureDirectories();
  
  // Create protocol handlers
  setupProtocols();
  
  // Set up IPC handlers for database operations
  setupDatabaseIpcHandlers();
  
  // Create window
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Create application support directory and download directories if they don't exist
const appSupportPath = path.join(
  app.getPath('userData')
);

// Existing paths
const stickersPath = path.join(appSupportPath, 'stickers');
const imagesPath = path.join(appSupportPath, 'images');
const previewsPath = path.join(appSupportPath, 'previews');

// Download paths
const downloadsPath = path.join(appSupportPath, 'downloads');
const downloadedImagesPath = path.join(downloadsPath, 'images');
const downloadedPdfsPath = path.join(downloadsPath, 'pdfs');

// Use path.join to ensure correct path resolution for native modules

// IPC handlers for printing
ipcMain.handle('print-pdf', async (event, { filePath, printerName, copies = 1, options = {} }) => {
  return new Promise((resolve, reject) => {
    try {
      let command = '';
      let tempScriptPath = ''; // For Windows temporary script
      
      if (platform() === 'darwin') {
        // macOS printing using lp
        command = `lp -d "${printerName}" -n ${copies}`;
        
        // Add options if provided
        if (options.media) {
          command += ` -o media=${options.media}`;
        }
        
        if (options.orientation) {
          command += ` -o orientation-requested=${options.orientation}`;
        }
        
        if (options.fitToPage !== undefined) {
          command += ` -o fit-to-page`;
        }
        
        if (options.printScaling) {
          command += ` -o print-scaling=${options.printScaling}`;
        }
        
        command += ` "${filePath}"`;
      } else if (platform() === 'win32') {
        // Windows printing using native system commands
        // Create a temporary PowerShell script to handle the printing
        tempScriptPath = path.join(app.getPath('temp'), 'print-script.ps1');
        
        // Build PowerShell script content
        let scriptContent = `
$printer = "${printerName}"
$file = "${filePath.replace(/\\/g, '\\\\')}"
$copies = ${copies}

# Load the file as a PrintDocument
Add-Type -AssemblyName System.Drawing
Add-Type -AssemblyName System.Windows.Forms
$printDoc = New-Object System.Drawing.Printing.PrintDocument
$printDoc.PrinterSettings.PrinterName = $printer
$printDoc.PrinterSettings.Copies = $copies

# Create event handler for printing
$printDoc.add_PrintPage({
    param($sender, $eventArgs)
    
    # For PDF files, use Windows shell to print
    Start-Process -FilePath "$file" -Verb Print -PassThru | %{
        # Wait for process to complete or timeout
        $completed = $_.WaitForExit(30000) 
        if (-not $completed) {
            $_.Kill()
        }
    }
    
    # Tell the document we're done printing
    $eventArgs.HasMorePages = $false
})

$printDoc.Print()
`;
        
        // Write script to temp file
        fs.writeFileSync(tempScriptPath, scriptContent);
        
        // Execute PowerShell script
        command = `powershell -ExecutionPolicy Bypass -File "${tempScriptPath}"`;
      } else {
        reject(new Error('Unsupported platform'));
        return;
      }
      
      exec(command, (error, stdout, stderr) => {
        if (error) {
          console.error('Error printing:', error);
          reject(error);
          return;
        }
        
        // Clean up temporary script file on Windows
        if (platform() === 'win32' && tempScriptPath) {
          try {
            fs.unlinkSync(tempScriptPath);
          } catch (err) {
            console.warn('Failed to clean up temporary script:', err);
          }
        }
        
        console.log('Print job sent to printer');
        console.log('stdout:', stdout);
        console.log('stderr:', stderr);
        resolve({ success: true, message: 'Print job sent to printer' });
      });
    } catch (error) {
      reject(error);
    }
  });
});

// Handle printing a sticker
ipcMain.handle('print-sticker', async (event, stickerId) => {
  try {
    // Get the sticker
    const sticker = db.getSticker(stickerId);
    if (!sticker) {
      console.error(`Sticker not found: ${stickerId}`);
      return { success: false, message: 'Sticker not found' };
    }
    
    console.log(`Found sticker with size: ${sticker.size}`);

    // Get printer settings for the sticker size
    const settings = db.getPrinterSettings();
    console.log(`Available printer settings: ${settings.map(s => s.size).join(', ')}`);
    
    const printerSetting = settings.find(s => s.size === sticker.size);
    
    if (!printerSetting) {
      console.error(`No printer setting found for size: ${sticker.size}`);
      return { success: false, message: `No printer configured for size: ${sticker.size}` };
    }
    
    console.log(`Using printer setting: ${JSON.stringify(printerSetting)}`);

    // Get the PDF path
    let pdfPath = '';
    if (sticker.localPdfPath && fs.existsSync(sticker.localPdfPath)) {
      pdfPath = sticker.localPdfPath;
    } else if (sticker.pdfUrl && sticker.pdfUrl.startsWith('app://pdfs/')) {
      const pdfFileName = sticker.pdfUrl.replace('app://pdfs/', '');
      pdfPath = path.join(downloadedPdfsPath, pdfFileName);
    }

    if (!pdfPath || !fs.existsSync(pdfPath)) {
      console.error(`PDF file not found for sticker: ${stickerId}`);
      return { success: false, message: 'PDF file not found' };
    }

    // Start with basic printer command
    let printCommand = `lp -d "${printerSetting.printerName}"`;
    
    // Add options from the printer settings if available
    if (printerSetting.options) {
      // Add media size
      if (printerSetting.options.media) {
        printCommand += ` -o media=${printerSetting.options.media}`;
      } else if (printerSetting.size) {
        // Extract dimensions from size and create custom media size
        const sizeParts = printerSetting.size.toLowerCase().split('x');
        if (sizeParts.length === 2) {
          const width = sizeParts[0].replace(/\D/g, '');
          const height = sizeParts[1].replace(/\D/g, '');
          printCommand += ` -o media=Custom.${width}x${height}mm`;
        }
      }
      
      // Add orientation
      if (printerSetting.options.orientation) {
        const orientationValue = printerSetting.options.orientation === 'landscape' ? '4' : '3';
        printCommand += ` -o orientation-requested=${orientationValue}`;
      }
      
      // Add scaling
      if (printerSetting.options.scale && printerSetting.options.scale !== 100) {
        printCommand += ` -o scaling=${printerSetting.options.scale}`;
      }
      
      // Add fit-to-page option
      if (printerSetting.options.fitToPage) {
        printCommand += ` -o fit-to-page`;
      }
      
      // Add print scaling option
      if (printerSetting.options.printScaling) {
        printCommand += ` -o print-scaling=${printerSetting.options.printScaling}`;
      }
      
      // Add margin options if present
      if (printerSetting.options.margins) {
        const { top, right, bottom, left, units } = printerSetting.options.margins;
        
        // Convert margins to points based on the units
        const toPoints = (value: number, unit: string) => {
          if (unit === 'mm') return value * 2.83465; // 1mm = 2.83465pt
          if (unit === 'in') return value * 72; // 1in = 72pt
          return value; // Already in points
        };
        
        // Add each margin with proper unit conversion
        if (top !== undefined) printCommand += ` -o page-top=${toPoints(top, units)}pt`;
        if (right !== undefined) printCommand += ` -o page-right=${toPoints(right, units)}pt`;
        if (bottom !== undefined) printCommand += ` -o page-bottom=${toPoints(bottom, units)}pt`;
        if (left !== undefined) printCommand += ` -o page-left=${toPoints(left, units)}pt`;
      }
    }
    
    // Add file path at the end
    printCommand += ` "${pdfPath}"`;
    console.log(`Printing with command: ${printCommand}`);
    
    // Execute print command
    try {
      const result = await new Promise((resolve, reject) => {
        exec(printCommand, (error, stdout, stderr) => {
          if (error) {
            console.error(`Print error: ${error.message}`);
            if (stderr) {
              console.error(`Error stderr: ${stderr}`);
            }
            reject(error);
            return;
          }
          
          if (stderr && stderr.trim() !== '') {
            console.warn(`Print stderr: ${stderr}`);
          }
          
          console.log(`Print stdout: ${stdout}`);
          resolve({ success: true, stdout });
        });
      });
      
      return { success: true, message: 'Sticker sent to printer' };
    } catch (error) {
      console.error('Error executing print command:', error);
      return { success: false, message: `Failed to print: ${error.message}` };
    }
  } catch (error) {
    console.error('Error printing sticker:', error);
    return { success: false, message: error.message || 'An unexpected error occurred' };
  }
});

// IPC handlers for file operations
ipcMain.handle('save-file', async (event, { data, fileName, directory }) => {
  const targetDir = directory === 'stickers' 
    ? stickersPath 
    : directory === 'images' 
      ? imagesPath 
      : directory === 'previews' 
        ? previewsPath 
        : appSupportPath;
  
  const filePath = path.join(targetDir, fileName);
  
  return new Promise((resolve, reject) => {
    fs.writeFile(filePath, Buffer.from(data), (err) => {
      if (err) {
        reject(err);
        return;
      }
      resolve({ success: true, filePath });
    });
  });
});

ipcMain.handle('get-file-path', (event, { fileName, directory }) => {
  const targetDir = directory === 'stickers' 
    ? stickersPath 
    : directory === 'images' 
      ? imagesPath 
      : directory === 'previews' 
        ? previewsPath 
        : appSupportPath;
  
  return path.join(targetDir, fileName);
});

ipcMain.handle('check-file-exists', (event, { fileName, directory }) => {
  const targetDir = directory === 'stickers' 
    ? stickersPath 
    : directory === 'images' 
      ? imagesPath 
      : directory === 'previews' 
        ? previewsPath 
        : appSupportPath;
  
  const filePath = path.join(targetDir, fileName);
  return fs.existsSync(filePath);
});

ipcMain.handle('get-app-path', () => {
  return {
    appSupportPath,
    stickersPath,
    imagesPath,
    previewsPath
  };
});

// Database IPC handlers
function setupDatabaseIpcHandlers() {
  // App settings handlers
  ipcMain.handle('db:getAppSetting', async (event, key) => {
    return db.getAppSetting(key);
  });
  
  ipcMain.handle('db:createOrUpdateAppSetting', async (event, key, value) => {
    return await db.createOrUpdateAppSetting(key, value);
  });
  
  ipcMain.handle('db:deleteAppSetting', async (event, key) => {
    return await db.deleteAppSetting(key);
  });
  
  ipcMain.handle('db:getAllAppSettings', async () => {
    return db.getAppSettings();
  });

  // Product handlers
  ipcMain.handle('db-get-products', async () => {
    return db.getProducts();
  });

  ipcMain.handle('db-get-products-by-type', (event, type) => {
    return db.getProductsByType(type);
  });

  ipcMain.handle('db-search-products', (event, query) => {
    return db.searchProducts(query);
  });

  ipcMain.handle('db-get-product', (event, id) => {
    return db.getProduct(id);
  });

  ipcMain.handle('db-update-product', async (event, id, data) => {
    return db.updateProduct(id, data);
  });

  // Sticker handlers
  ipcMain.handle('db-get-stickers', async (event, productId) => {
    try {
      console.log(`Fetching stickers for product ${productId}`);
      const stickers = db.getStickers(productId);
      console.log(`Found ${stickers.length} stickers for product ${productId}`);
      return stickers;
    } catch (error) {
      console.error(`Error fetching stickers for product ${productId}:`, error);
      return [];
    }
  });

  ipcMain.handle('db-update-sticker', async (event, id, data) => {
    return db.updateSticker(id, data);
  });

  // Printer settings handlers
  ipcMain.handle('db-get-printer-settings', async () => {
    try {
      return db.getPrinterSettings();
    } catch (error) {
      console.error('Error getting printer settings:', error);
      throw error;
    }
  });

  ipcMain.handle('db-update-printer-settings', async (event, settings) => {
    try {
      console.log('Updating printer settings:', settings);
      return await db.updatePrinterSettings(settings);
    } catch (error) {
      console.error('Error updating printer settings:', error);
      throw error;
    }
  });

  ipcMain.handle('db-get-printer-setting', async (event, size) => {
    try {
      const settings = db.getPrinterSettings();
      const setting = settings.find(s => s.size === size);
      return setting || null;
    } catch (error) {
      console.error(`Error getting printer setting for size ${size}:`, error);
      throw error;
    }
  });

  ipcMain.handle('db-create-printer-setting', async (event, printerSetting) => {
    try {
      return await db.createPrinterSetting(printerSetting);
    } catch (error) {
      console.error('Error creating printer setting:', error);
      throw error;
    }
  });

  // Notion settings handlers
  ipcMain.handle('db-get-notion-settings', async () => {
    return db.getNotionSetting();
  });

  ipcMain.handle('db-save-notion-settings', async (event, settings) => {
    return db.createOrUpdateNotionSetting(settings);
  });

  // Google Drive settings handlers
  ipcMain.handle('db-get-google-drive-settings', async () => {
    return db.getGoogleDriveSetting();
  });

  ipcMain.handle('db-save-google-drive-settings', async (event, settings) => {
    try {
      const serviceAccount = JSON.parse(settings.serviceAccountJson);
      if (!serviceAccount.client_email || !serviceAccount.private_key) {
        console.error('Missing required fields in service account JSON');
        return { success: false, message: 'Invalid service account JSON format' };
      }
      return db.createOrUpdateGoogleDriveSetting(settings);
    } catch (error) {
      console.error('Error saving Google Drive settings:', error);
      throw error;
    }
  });

  // General settings handler
  ipcMain.handle('db-get-general-settings', () => {
    return db.getGeneralSettings();
  });

  ipcMain.handle('db-save-general-settings', async (event, settings) => {
    try {
      // Save each setting individually using createOrUpdateAppSetting
      for (const [key, value] of Object.entries(settings)) {
        await db.createOrUpdateAppSetting(key, value);
      }
      return { success: true };
    } catch (error) {
      console.error('Error saving general settings:', error);
      throw error;
    }
  });
}

// IPC handler for synchronizing with Notion
ipcMain.handle('sync-notion', async (event) => {
  try {
    // Очищаємо базу даних перед синхронізацією
    console.log('Cleared all products and stickers from the database');
    
    // Синхронізуємося з Notion
    const result = await syncWithNotion();
    console.log('Notion sync result:', result);
    
    return result;
  } catch (error) {
    console.error('Error in sync-notion handler:', error);
    return { success: false, message: error.message };
  }
});

// Get available printers
ipcMain.handle('get-available-printers', async () => {
  return new Promise((resolve, reject) => {
    try {
      if (platform() === 'darwin') {
        // macOS: Use lpstat to get printer list
        exec('lpstat -p | grep -o "printer [^ ]* is" | cut -d " " -f 2', (error, stdout, stderr) => {
          if (error) {
            console.error('Error getting printers:', error);
            resolve([]);
            return;
          }
          
          const printers = stdout.trim().split('\n').filter(Boolean);
          console.log('Available printers:', printers);
          resolve(printers);
        });
      } else if (platform() === 'win32') {
        // Windows: Use wmic to get printer list
        exec('wmic printer get name', (error, stdout, stderr) => {
          if (error) {
            console.error('Error getting printers:', error);
            resolve([]);
            return;
          }
          
          // Parse output, skipping the header line
          const printers = stdout.trim().split('\n').slice(1).map(p => p.trim()).filter(Boolean);
          console.log('Available printers:', printers);
          resolve(printers);
        });
      } else {
        console.warn('Unsupported platform for printer listing');
        resolve([]);
      }
    } catch (error) {
      console.error('Error listing printers:', error);
      resolve([]);
    }
  });
});

// Clear products before syncing
ipcMain.handle('db-clear-products', async () => {
  try {
    return db.clearProducts();
  } catch (error) {
    console.error('Error clearing products:', error);
    return false;
  }
});

// Add this new IPC handler to download files
ipcMain.handle('download-file', async (event, fileUrl, filePath) => {
  try {
    if (!fileUrl) {
      return { success: false, message: 'No URL provided' };
    }
    
    return new Promise((resolve, reject) => {
      const parsedUrl = new URL(fileUrl);
      const protocol = parsedUrl.protocol === 'https:' ? https : http;
      
      console.log(`Downloading file from ${fileUrl} to ${filePath}`);
      
      const fileStream = fs.createWriteStream(filePath);
      
      const request = protocol.get(fileUrl, (response) => {
        if (response.statusCode !== 200) {
          reject(new Error(`Failed to download file: ${response.statusCode}`));
          return;
        }
        
        response.pipe(fileStream);
        
        fileStream.on('finish', () => {
          fileStream.close();
          console.log(`Download complete: ${filePath}`);
          resolve({ success: true, filePath });
        });
      });
      
      request.on('error', (err) => {
        fs.unlink(filePath, () => {}); // Delete the file if download failed
        console.error(`Download failed: ${err.message}`);
        reject(err);
      });
      
      fileStream.on('error', (err) => {
        fs.unlink(filePath, () => {}); // Delete the file if write failed
        console.error(`File write failed: ${err.message}`);
        reject(err);
      });
    });
  } catch (error) {
    console.error('Error downloading file:', error);
    return { success: false, message: error.message };
  }
});

// Функція для створення необхідних директорій
function ensureDirectories() {
  const directories = [
    imagesPath,
    downloadedImagesPath,
    downloadedPdfsPath,
    previewsPath,
    path.join(appSupportPath, 'pdfs')
  ];
  
  console.log('Ensuring required directories exist...');
  
  for (const dir of directories) {
    try {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log(`Created directory: ${dir}`);
      }
    } catch (error) {
      console.error(`Error creating directory ${dir}:`, error);
    }
  }
  
  console.log('Directory check completed');
}

// Create protocol handlers
function setupProtocols() {
  // Register protocol to handle app:// URLs
  protocol.registerFileProtocol('app', (request, callback) => {
    const url = request.url.substring(6); // Remove 'app://'
    const decodedUrl = decodeURI(url);
    
    let filePath;
    let fileFound = false;

    // Image handling
    if (decodedUrl.startsWith('images/')) {
      const imageName = decodedUrl.replace('images/', '');
      
      // Check in downloadedImagesPath first
      filePath = path.join(downloadedImagesPath, imageName);
      
      if (fs.existsSync(filePath)) {
        fileFound = true;
      } else {
        // If not found, check in imagesPath
        filePath = path.join(imagesPath, imageName);
        fileFound = fs.existsSync(filePath);
        
        if (!fileFound) {
          console.error(`Image not found: ${imageName} (checked in ${downloadedImagesPath} and ${imagesPath})`);
        }
      }
    } 
    // PDF handling
    else if (decodedUrl.startsWith('pdfs/')) {
      const pdfName = decodedUrl.replace('pdfs/', '');
      
      // Check in downloadedPdfsPath first
      filePath = path.join(downloadedPdfsPath, pdfName);
      
      if (fs.existsSync(filePath)) {
        fileFound = true;
      } else {
        // If not found, check in appSupportPath
        filePath = path.join(appSupportPath, 'pdfs', pdfName);
        fileFound = fs.existsSync(filePath);
        
        if (!fileFound) {
          console.error(`PDF not found: ${pdfName} (checked in ${downloadedPdfsPath} and ${path.join(appSupportPath, 'pdfs')})`);
        }
      }
    } 
    // Preview handling
    else if (decodedUrl.startsWith('previews/')) {
      const previewName = decodedUrl.replace('previews/', '');
      filePath = path.join(previewsPath, previewName);
      
      fileFound = fs.existsSync(filePath);
      
      // If preview doesn't exist, create a 1x1 transparent PNG as placeholder
      if (!fileFound) {
        try {
          console.warn(`Preview not found: ${previewName}, creating placeholder`);
          
          // Ensure directory exists
          if (!fs.existsSync(previewsPath)) {
            fs.mkdirSync(previewsPath, { recursive: true });
          }
          
          // Create a 1x1 transparent PNG
          const transparentPNG = Buffer.from('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=', 'base64');
          fs.writeFileSync(filePath, transparentPNG);
          console.log(`Created placeholder at ${filePath}`);
          fileFound = true;
        } catch (err) {
          console.error(`Failed to create placeholder for ${previewName}:`, err);
        }
      }
    } 
    // Default behavior for other paths
    else {
      filePath = path.join(appSupportPath, decodedUrl);
      fileFound = fs.existsSync(filePath);
    }
    
    console.log(`app:// protocol request: ${decodedUrl} => ${filePath} (found: ${fileFound})`);
    callback({ path: filePath });
  });
}

ipcMain.handle('create-sticker', async (event, stickerData) => {
  try {
    console.log(`Creating sticker: ${JSON.stringify(stickerData)}`);
    
    // Додаємо необхідні поля, якщо відсутні
    const completeData = {
      ...stickerData,
      createdAt: stickerData.createdAt || new Date().toISOString(),
      updatedAt: stickerData.updatedAt || new Date().toISOString()
    };
    
    const sticker = await db.createSticker(completeData);
    
    // Зберігаємо базу даних після створення стікера
    await db.saveDatabase();
    
    console.log(`Created sticker with ID ${sticker.id}`);
    return sticker;
  } catch (error) {
    console.error('Error creating sticker:', error);
    throw error;
  }
}); 