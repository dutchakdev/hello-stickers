import { app, BrowserWindow, ipcMain, dialog, protocol, Menu } from 'electron';
import * as path from 'path';
import * as fs from 'fs';
import { exec, execFile } from 'child_process';
import { platform } from 'os';
import db from '../database/db';
import * as https from 'https';
import * as http from 'http';
import { URL } from 'url';
import * as googleDrive from '../lib/google-drive';
import { syncWithNotion } from '../lib/notion';
import * as querystring from 'querystring';

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// This allows TypeScript to pick up the magic constants that's auto-generated by Electron Forge.
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
      webSecurity: true,
      sandbox: false
    },
  });

  // Content security policy to protect against XSS
  const csp = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-eval'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: app: https://* file:",
    "media-src 'self' app:",
    "font-src 'self'",
    "object-src 'self' app: blob:",
    "connect-src 'self' https://*"
  ].join('; ');
  
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [csp]
      }
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
  
  console.log('Preload path:', MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY);
};

// This method will be called when Electron has finished initialization
// and is ready to create browser windows.
app.whenReady().then(() => {
  // Initialize database
  db.initDatabase();
  
  // Ensure directories exist
  ensureDirectories();
  
  // Create protocol handlers
  setupProtocols();
  
  // Set up IPC handlers for database operations
  setupDatabaseIpcHandlers();
  
  // Create window
  createWindow();
  
  // Create default stickers for products that don't have them
  createDefaultStickersForProducts().catch(err => {
    console.error('Error creating default stickers:', err);
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Create application support directory and download directories if they don't exist
const appSupportPath = path.join(
  app.getPath('userData')
);

// Existing paths
const stickersPath = path.join(appSupportPath, 'stickers');
const imagesPath = path.join(appSupportPath, 'images');
const previewsPath = path.join(appSupportPath, 'previews');

// Download paths
const downloadsPath = path.join(appSupportPath, 'downloads');
const downloadedImagesPath = path.join(downloadsPath, 'images');
const downloadedPdfsPath = path.join(downloadsPath, 'pdfs');

// Use path.join to ensure correct path resolution for native modules

// IPC handlers for printing
ipcMain.handle('print-pdf', async (event, { filePath, printerName, copies = 1, options = {} }) => {
  return new Promise((resolve, reject) => {
    try {
      let command = '';
      
      if (platform() === 'darwin') {
        // macOS printing using lp
        command = `lp -d "${printerName}" -n ${copies}`;
        
        // Add options if provided
        if (options.media) {
          command += ` -o media=${options.media}`;
        }
        
        if (options.orientation) {
          command += ` -o orientation-requested=${options.orientation}`;
        }
        
        if (options.fitToPage !== undefined) {
          command += ` -o fit-to-page`;
        }
        
        if (options.printScaling) {
          command += ` -o print-scaling=${options.printScaling}`;
        }
        
        command += ` "${filePath}"`;
      } else if (platform() === 'win32') {
        // Windows printing using SumatraPDF (needs to be installed)
        // This is a simplified example - you may need to adjust based on your Windows setup
        command = `SumatraPDF.exe -print-to "${printerName}" -print-settings "copies=${copies}" "${filePath}"`;
      } else {
        reject(new Error('Unsupported platform'));
        return;
      }
      
      exec(command, (error, stdout, stderr) => {
        if (error) {
          console.error(`Print error: ${error.message}`);
          reject(error);
          return;
        }
        if (stderr) {
          console.error(`Print stderr: ${stderr}`);
        }
        resolve({ success: true, stdout });
      });
    } catch (error) {
      reject(error);
    }
  });
});

// IPC handlers for file operations
ipcMain.handle('save-file', async (event, { data, fileName, directory }) => {
  const targetDir = directory === 'stickers' 
    ? stickersPath 
    : directory === 'images' 
      ? imagesPath 
      : directory === 'previews' 
        ? previewsPath 
        : appSupportPath;
  
  const filePath = path.join(targetDir, fileName);
  
  return new Promise((resolve, reject) => {
    fs.writeFile(filePath, Buffer.from(data), (err) => {
      if (err) {
        reject(err);
        return;
      }
      resolve({ success: true, filePath });
    });
  });
});

ipcMain.handle('get-file-path', (event, { fileName, directory }) => {
  const targetDir = directory === 'stickers' 
    ? stickersPath 
    : directory === 'images' 
      ? imagesPath 
      : directory === 'previews' 
        ? previewsPath 
        : appSupportPath;
  
  return path.join(targetDir, fileName);
});

ipcMain.handle('check-file-exists', (event, { fileName, directory }) => {
  const targetDir = directory === 'stickers' 
    ? stickersPath 
    : directory === 'images' 
      ? imagesPath 
      : directory === 'previews' 
        ? previewsPath 
        : appSupportPath;
  
  const filePath = path.join(targetDir, fileName);
  return fs.existsSync(filePath);
});

ipcMain.handle('get-app-path', () => {
  return {
    appSupportPath,
    stickersPath,
    imagesPath,
    previewsPath
  };
});

// Database IPC handlers
function setupDatabaseIpcHandlers() {
  // App settings handlers
  ipcMain.handle('db:getAppSetting', async (event, key) => {
    return db.getAppSetting(key);
  });
  
  ipcMain.handle('db:createOrUpdateAppSetting', async (event, key, value) => {
    return await db.createOrUpdateAppSetting(key, value);
  });
  
  ipcMain.handle('db:deleteAppSetting', async (event, key) => {
    return await db.deleteAppSetting(key);
  });
  
  ipcMain.handle('db:getAllAppSettings', async () => {
    return db.getAppSettings();
  });

  // Product handlers
  ipcMain.handle('db-get-products', async () => {
    return db.getProducts();
  });

  ipcMain.handle('db-get-products-by-type', (event, type) => {
    return db.getProductsByType(type);
  });

  ipcMain.handle('db-search-products', (event, query) => {
    return db.searchProducts(query);
  });

  ipcMain.handle('db-get-product', (event, id) => {
    return db.getProduct(id);
  });

  ipcMain.handle('db-update-product', async (event, id, data) => {
    return db.updateProduct(id, data);
  });

  // Sticker handlers
  ipcMain.handle('db-get-stickers', async (event, productId) => {
    try {
      console.log(`Fetching stickers for product ${productId}`);
      const stickers = db.getStickers(productId);
      console.log(`Found ${stickers.length} stickers for product ${productId}`);
      return stickers;
    } catch (error) {
      console.error(`Error fetching stickers for product ${productId}:`, error);
      return [];
    }
  });

  ipcMain.handle('db-update-sticker', async (event, id, data) => {
    return db.updateSticker(id, data);
  });

  // Printer settings handlers
  ipcMain.handle('db-get-printer-settings', async () => {
    try {
      return db.getPrinterSettings();
    } catch (error) {
      console.error('Error getting printer settings:', error);
      throw error;
    }
  });

  ipcMain.handle('db-get-printer-setting', async (event, size) => {
    try {
      const settings = db.getPrinterSettings();
      const setting = settings.find(s => s.size === size);
      return setting || null;
    } catch (error) {
      console.error(`Error getting printer setting for size ${size}:`, error);
      throw error;
    }
  });

  ipcMain.handle('db-create-printer-setting', async (event, printerSetting) => {
    try {
      return await db.createPrinterSetting(printerSetting);
    } catch (error) {
      console.error('Error creating printer setting:', error);
      throw error;
    }
  });

  // Notion settings handlers
  ipcMain.handle('db-get-notion-settings', async () => {
    return db.getNotionSetting();
  });

  ipcMain.handle('db-save-notion-settings', async (event, settings) => {
    return db.createOrUpdateNotionSetting(settings);
  });

  // Google Drive settings handlers
  ipcMain.handle('db-get-google-drive-settings', async () => {
    return db.getGoogleDriveSetting();
  });

  ipcMain.handle('db-save-google-drive-settings', async (event, settings) => {
    try {
      const serviceAccount = JSON.parse(settings.serviceAccountJson);
      if (!serviceAccount.client_email || !serviceAccount.private_key) {
        console.error('Missing required fields in service account JSON');
        return { success: false, message: 'Invalid service account JSON format' };
      }
      return db.createOrUpdateGoogleDriveSetting(settings);
    } catch (error) {
      console.error('Error saving Google Drive settings:', error);
      throw error;
    }
  });

  // General settings handler
  ipcMain.handle('db-get-general-settings', () => {
    return db.getGeneralSettings();
  });
}

// IPC handler for synchronizing with Notion
ipcMain.handle('sync-notion', async (event) => {
  try {
    // Очищаємо базу даних перед синхронізацією
    console.log('Cleared all products and stickers from the database');
    
    // Синхронізуємося з Notion
    const result = await syncWithNotion();
    console.log('Notion sync result:', result);
    
    // Створюємо наліпки за замовчуванням після синхронізації
    await createDefaultStickersForProducts();
    
    return result;
  } catch (error) {
    console.error('Error in sync-notion handler:', error);
    return { success: false, message: error.message };
  }
});

// Helper functions for Notion integration
async function createStickers(productIds: string[]): Promise<void> {
  try {
    for (const productId of productIds) {
      const product = await db.getProduct(productId);
      if (!product) continue;
      
      const existingStickers = await db.getStickers(productId);
      
      if (existingStickers.length === 0) {
        // Create a price tag sticker if none exists
        await db.createSticker({
          productId,
          name: `${product.name} Price Tag`,
          size: '50x30mm',
          pdfUrl: null,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        });
        
        console.log(`Created price tag sticker for ${product.name}`);
      }
    }
  } catch (error) {
    console.error('Error creating stickers:', error);
  }
}

// Get available printers
ipcMain.handle('get-available-printers', async () => {
  if (mainWindow) {
    // Use a simpler approach that doesn't rely on getPrinters
    return ['Default Printer']; // Mock printer for now
  }
  return [];
});

// Handle printing a sticker
ipcMain.handle('print-sticker', async (event, stickerId) => {
  try {
    const sticker = db.getSticker(stickerId);
    if (!sticker || !sticker.pdfUrl) {
      return { success: false, message: 'Sticker not found or PDF URL not available' };
    }
    
    // Extract PDF path from the app:// URL
    const pdfUrl = sticker.pdfUrl;
    const pdfPath = pdfUrl.replace('app://pdfs/', '');
    const fullPdfPath = path.join(downloadedPdfsPath, pdfPath);
    
    if (!fs.existsSync(fullPdfPath)) {
      return { success: false, message: `PDF file not found at ${fullPdfPath}` };
    }
    
    // Get printer settings for the sticker size
    const settings = db.getPrinterSettings();
    const printerSetting = settings.find(s => s.size === sticker.size);
    
    if (!printerSetting) {
      return { success: false, message: `No printer setting for size ${sticker.size}` };
    }
    
    // Return success for now - we'll implement actual printing in a follow-up
    console.log(`Would print ${fullPdfPath} to printer ${printerSetting.size}`);
    return { success: true, message: 'Sticker sent to printer' };
  } catch (error) {
    console.error('Error printing sticker:', error);
    return { success: false, message: error.message };
  }
});

// Clear products before syncing
ipcMain.handle('db-clear-products', async () => {
  try {
    return db.clearProducts();
  } catch (error) {
    console.error('Error clearing products:', error);
    return false;
  }
});

// Add this new IPC handler to download files
ipcMain.handle('download-file', async (event, fileUrl, filePath) => {
  try {
    if (!fileUrl) {
      return { success: false, message: 'No URL provided' };
    }
    
    return new Promise((resolve, reject) => {
      const parsedUrl = new URL(fileUrl);
      const protocol = parsedUrl.protocol === 'https:' ? https : http;
      
      console.log(`Downloading file from ${fileUrl} to ${filePath}`);
      
      const fileStream = fs.createWriteStream(filePath);
      
      const request = protocol.get(fileUrl, (response) => {
        if (response.statusCode !== 200) {
          reject(new Error(`Failed to download file: ${response.statusCode}`));
          return;
        }
        
        response.pipe(fileStream);
        
        fileStream.on('finish', () => {
          fileStream.close();
          console.log(`Download complete: ${filePath}`);
          resolve({ success: true, filePath });
        });
      });
      
      request.on('error', (err) => {
        fs.unlink(filePath, () => {}); // Delete the file if download failed
        console.error(`Download failed: ${err.message}`);
        reject(err);
      });
      
      fileStream.on('error', (err) => {
        fs.unlink(filePath, () => {}); // Delete the file if write failed
        console.error(`File write failed: ${err.message}`);
        reject(err);
      });
    });
  } catch (error) {
    console.error('Error downloading file:', error);
    return { success: false, message: error.message };
  }
});

// Функція для створення наліпок за замовчуванням для продуктів, якщо вони відсутні
async function createDefaultStickersForProducts() {
  console.log('Creating default stickers for products if needed');
  try {
    const products = db.getProducts();
    console.log(`Checking ${products.length} products for default stickers`);
    
    for (const product of products) {
      try {
        const stickers = db.getStickers(product.id);
        console.log(`Product ${product.sku || product.id} has ${stickers.length} stickers`);
        
        if (stickers.length === 0) {
          console.log(`Creating default price tag sticker for product ${product.sku || product.id}`);
          
          const defaultSticker = {
            productId: product.id,
            name: 'Price Tag',
            size: 'Default',
            pdfUrl: null,
            previewUrl: null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };
          
          const completeData = {
            ...defaultSticker,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };
          
          const createdSticker = await db.createSticker(defaultSticker);
          console.log(`Created default sticker with ID ${createdSticker.id}`);
        }
      } catch (error) {
        console.error(`Error creating default stickers for product ${product.sku || product.id}:`, error);
      }
    }
    
    await db.saveDatabase();
    console.log('Default stickers creation completed');
  } catch (error) {
    console.error('Error creating default stickers:', error);
  }
}

// Функція для створення необхідних директорій
function ensureDirectories() {
  const directories = [
    imagesPath,
    downloadedImagesPath,
    downloadedPdfsPath,
    previewsPath,
    path.join(appSupportPath, 'pdfs')
  ];
  
  console.log('Ensuring required directories exist...');
  
  for (const dir of directories) {
    try {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log(`Created directory: ${dir}`);
      }
    } catch (error) {
      console.error(`Error creating directory ${dir}:`, error);
    }
  }
  
  console.log('Directory check completed');
}

// Create protocol handlers
function setupProtocols() {
  // Register protocol to handle app:// URLs
  protocol.registerFileProtocol('app', (request, callback) => {
    const url = request.url.substring(6); // Remove 'app://'
    const decodedUrl = decodeURI(url);
    
    let filePath;
    let fileFound = false;

    // Image handling
    if (decodedUrl.startsWith('images/')) {
      const imageName = decodedUrl.replace('images/', '');
      
      // Check in downloadedImagesPath first
      filePath = path.join(downloadedImagesPath, imageName);
      
      if (fs.existsSync(filePath)) {
        fileFound = true;
      } else {
        // If not found, check in imagesPath
        filePath = path.join(imagesPath, imageName);
        fileFound = fs.existsSync(filePath);
        
        if (!fileFound) {
          console.error(`Image not found: ${imageName} (checked in ${downloadedImagesPath} and ${imagesPath})`);
        }
      }
    } 
    // PDF handling
    else if (decodedUrl.startsWith('pdfs/')) {
      const pdfName = decodedUrl.replace('pdfs/', '');
      
      // Check in downloadedPdfsPath first
      filePath = path.join(downloadedPdfsPath, pdfName);
      
      if (fs.existsSync(filePath)) {
        fileFound = true;
      } else {
        // If not found, check in appSupportPath
        filePath = path.join(appSupportPath, 'pdfs', pdfName);
        fileFound = fs.existsSync(filePath);
        
        if (!fileFound) {
          console.error(`PDF not found: ${pdfName} (checked in ${downloadedPdfsPath} and ${path.join(appSupportPath, 'pdfs')})`);
        }
      }
    } 
    // Preview handling
    else if (decodedUrl.startsWith('previews/')) {
      const previewName = decodedUrl.replace('previews/', '');
      filePath = path.join(previewsPath, previewName);
      
      fileFound = fs.existsSync(filePath);
      
      // If preview doesn't exist, create a 1x1 transparent PNG as placeholder
      if (!fileFound) {
        try {
          console.warn(`Preview not found: ${previewName}, creating placeholder`);
          
          // Ensure directory exists
          if (!fs.existsSync(previewsPath)) {
            fs.mkdirSync(previewsPath, { recursive: true });
          }
          
          // Create a 1x1 transparent PNG
          const transparentPNG = Buffer.from('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=', 'base64');
          fs.writeFileSync(filePath, transparentPNG);
          console.log(`Created placeholder at ${filePath}`);
          fileFound = true;
        } catch (err) {
          console.error(`Failed to create placeholder for ${previewName}:`, err);
        }
      }
    } 
    // Default behavior for other paths
    else {
      filePath = path.join(appSupportPath, decodedUrl);
      fileFound = fs.existsSync(filePath);
    }
    
    console.log(`app:// protocol request: ${decodedUrl} => ${filePath} (found: ${fileFound})`);
    callback({ path: filePath });
  });
}

ipcMain.handle('create-sticker', async (event, stickerData) => {
  try {
    console.log(`Creating sticker: ${JSON.stringify(stickerData)}`);
    
    // Додаємо необхідні поля, якщо відсутні
    const completeData = {
      ...stickerData,
      createdAt: stickerData.createdAt || new Date().toISOString(),
      updatedAt: stickerData.updatedAt || new Date().toISOString()
    };
    
    const sticker = await db.createSticker(completeData);
    
    // Зберігаємо базу даних після створення стікера
    await db.saveDatabase();
    
    console.log(`Created sticker with ID ${sticker.id}`);
    return sticker;
  } catch (error) {
    console.error('Error creating sticker:', error);
    throw error;
  }
}); 